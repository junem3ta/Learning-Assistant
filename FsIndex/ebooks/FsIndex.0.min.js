/* 
    Collection ebooksFSIndex;
    var ebooksFSIndex = {
        "FSET":{
            "Y1":{
                "path":"root/FSET/Y1",
                "__files__":[]
            },
            "Y2":{},
            "Y3":{},
            "Y4":{},
            "Certificate":{},
            "Diploma":{}
        },
        "BUST":{},
        "FAES":{},
        "FAHU":{},
        "FRED":{}
    }

    collection Uploads:
    uploads = {
        "unassingend":{
            /* 
            @fileupload, @duplicate-check
                If hashfromfilename exists, inform author. If they persist, ask them to rename file to new filename.
            @24hr intervals, check uploads.unassigned. For a _single_ hashfromfilename obj:
                GET ModeratorsObj from moderatorsMetadata.(hashfromfilename.department).moderators.
                Iterate on ModeratorsObj and return moderatorID obj with least assignment count. Set id to the propname of this moderatorID.
                  Increment moderatorID.assignmentCount.
                  Update moderatorID.assignments with new property hashfromfilename:{path:path,filename:filename,author:email,uploaddate:ts}
                  Update uploads.pendingApproval w/new property hashfromfilename:{path:path,filename:filename,author:email,uploaddate:ts,moderator:{}}
                  Remove uploads.unassigned.hashfromfilename
                  Notify author.email with request_being_processed msg.
                  Notify moderatros.department.moderatorID.email with new_assignment msg.
                    /* 
                        You're receiving this email because you've been listed as a moderator for approving revision eBooks on eRead, Chuka University's e-Learning system. A new revision book named ${filename} for ${coursename} has been added and requires your review and approval.
                        Kindly use the link below to review the document. Your input is highly valued.

                        ._______________________________.
                        |                               |    /* <button>
                        |    Review ${filename}.pdf     |           <a href="eReadCU.com/signin/mod_approval_link/auth/processingid"></a>
                        |_______________________________|       </button> *//*


                        ~ "Working together to create a better learning resource."

                        Regards,
                        eReadCu.com

                        This is an automatically generated email. You can manage your account settings ${here}. Please do not reply to this mail.
                        For further assistance, write to supportcenter@eReadCU.com.
                    *//*

                  /* pendingApprovalMetadata? *//*

            "hashfromfilename": {
                "department": "FSET",
                "path":"mod/FSET/Y1",
                "filename":"filename.pdf",
                "author":contributor.emailaddr,
                "upload-date":timestamp
            }
        },
        "pendingApproval":{
            "hashfromfilename": {
                "path":"mod/FSET/Y1",
                "filename":"filename0.pdf",
                "author":contributor.emailaddr,
                "uploaddate":timestamp
                "moderator": {
                    "id":moderatorID,
                    "name":name,
                    "email":email
                },
                "allocatedToModerator": true,
                "notificationViewed": false,
            }
        },
        approved:{},
        "rejected":{}
    }
    
    collection Moderators:
    moderatorsMetadata = {
        "BUST":{},
        "FSET":{
            "moderators": {
                "moderatorID":{
                    "name":"",
                    "email":"",
                    "password":"",
                    "assignmentCount":1,//increment/decrement accordingly
                    "assignments":{ //add/delete entries accordingly
                        "hashfromfilename":{
                            "path":"mod/FSET/Y1",
                            "filename":"filenameInit.pdf"
                            "author":contributor.emailaddr,
                            "uploaddate": timestamp,
                            "notifiedOnUI": false,
                            "showOnUI": true, /* Give access to the service to update this value only after notification's opened *//*
                        }
                    }
                    "approvalHistory":{
                        "accepted":{
                            "hashfromfilename":{
                                "uploaddate": timestamp,
                                "approveddate": timestamp
                                "path":
                            }
                        },
                        "rejected":{
                            "hashfromfilename":{
                                "uploaddate":timestamp,
                                "approveddate": timestamp,
                                "path":
                            }
                        }
                    }
                }
            }
        },
        "FAES":{},
        "FAHU":{},
        "FRED":{}
    }

    /*  
        ACCOUNT SETTINGS 
        Default:
            Logged in as standard user UserID: {generateRandomUniqueHashValue?}
                :onDownload? 
                    sendRequest to request-parser API, get user-agent, timestamp.
                    getFilename, department from file attributes
                    invoke updateUniqueDownloads(uniqueHashUserID, user-agent, filename, department, timestamp);
                :show random avatar + uniqueHashUserID
                --------------------
                ?? use cookies to keep track of user preferences?
                    : UserAccounts?
                         Pros:
                            :Would do a great job improving UX, where a logged in user has their preferences preloaded.
                            :User settings are permanently persisted.
                        Cons: 
                            :Unique accounts for 20k students implies increased memory requirements.
                            :Issue when users forget pwds. Low likelihood(sp?) of users resetting their passwords? Reduced UX?
                    : SessionCookies?
                        Pros:
                            :Would do a great job improving UX, where a logged in user has their preferences preloaded.
                            :Reduced server-side db/processing requirements.
                        Cons:
                            :Requires prompting the use for details about their department, course.
                            :In case of browser cache being cleared / user replacing their device, all cookies would be reset.
                -------------------
                Upload new eBook(s) to Create user account (?):qn-circle.
                    > All content on eReadCU is open-source implying that the standard-user account is a super user account :) with access to 
                    all revision content. User accounts are only required for when you're contributing to the eRead Community, mainly for purposes 
                    of tracking the approval status of added content. 
                -------------------
                Moderators
                B.E HelperFn:
                    _mIDFromEmail(email) {
                        return  uniquehashvalue from entire email value (including @domain.ext)
                    }
                Login:
                    UI:Prompt for email, password.
                        :B.E.Process
                            :moderatorID = _mIDFromEmail(email);
                            :Loop through moderatorsMetadata.faculty.
                            :If moderatorsMetadata.faculty.moderators has obj moderatorID, return _faculty, _moderatorID (pointers to actual obj).
                                :else, return user not found
                        :B.E.NotificationService - After login, invoke process from BE immediately and render notifications to UI.
                            :userObj = ModeratorsMetadata._faculty.moderators._moderatorID.
                            :assingments = {}
                                :Loop through userObj.assignments
                                    hashFromFilename.showOnUI ? assignments.add(userObj.assignments.hashFromFilename) : assingments.add(null);
                        return email, _faculty, assignments to UI.
                Redirect on Successful Login.
                    :Use assignments obj on UI to render notifications.
                        :Loop through assignments
                            :assignments.hashfromfilename.notifiedOnUI==false ? Add _NEW_ marker to notification : Add _DELETE_ option to notification.
                    :Notification.onClick(), assignment = ID (hashfromfilename) 
                        B.E.process
                            _moderatorID = hashValueFromEmail.
                            Update ModeratorsMetadata._faculty.moderators._moderatorID.assignments.hashfromfilename, Set notifiedOnUI to true;
                            Update Uploads.pendingApproval.hashfromfilename, Set notificationViewed to true.
                    :DeleteNotification.onClick()
                        B.E.process
                            _moderatorID = _mIDFromEmail(email);
                            Update ModeratorsMetadata._faculty.moderators._moderatorID.assignments.hashfromfilename, Set showOnUI to false
                --------------------
                Contributors (?) - Login to track status of uploaded eBooks(?)
                /* Create contributors obj | UI/B.E Notification processes *//*
                            
    *//*


    /* publish my contributor info on approval? *//*
    Collection Contributors:
    contributors = {

    }
*/

/* 
    collection pastPapersMetadata = {
        @process updateUniqueDownloads(userId, useragent, filename, dept, time)
            if(pastPapersMetadata.UniqueDownloads.userId == undefined) {
                ::create new property in pastPapersMetadata.UniqueDownloads, set propertyname to userId.
                ::add user-agent and file-metadata to this property.
            } else {
                add new object with the properties filename, department, timestamp to files-downloaded arr 
            }
        UniqueDownloads {
            uniqueHashUserID : {
                user-agent: "browser-user-agent",
                files-downloaded: [
                    {
                        "name" : filename,
                        "department" : department,
                        timestamp: timestamp
                    }
                ],

            }
        }
    }
*/